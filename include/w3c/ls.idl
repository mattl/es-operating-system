/*
 * Copyright (c) 2004 World Wide Web Consortium,
 *
 * (Massachusetts Institute of Technology, European Research Consortium for
 * Informatics and Mathematics, Keio University). All Rights Reserved. This
 * work is distributed under the W3C(r) Software License [1] in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
 */

// File: http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/ls.idl

#ifndef _LS_IDL_
#define _LS_IDL_

#include "dom.idl"
#include "events.idl"
#include "traversal.idl"

#pragma prefix "dom.w3c.org"
module ls
{

  typedef   Object LSInputStream;

  typedef   Object LSOutputStream;

  typedef   Object LSReader;

  typedef   Object LSWriter;

  typedef dom::DOMString DOMString;
  typedef dom::DOMConfiguration DOMConfiguration;
  typedef dom::Node Node;
  typedef dom::Document Document;
  typedef dom::Element Element;

  interface LSParser;
  interface LSSerializer;
  interface LSInput;
  interface LSOutput;
  interface LSParserFilter;
  interface LSSerializerFilter;

  exception LSException {
    unsigned short   code;
  };
  // LSExceptionCode
  const unsigned short      PARSE_ERR                      = 81;
  const unsigned short      SERIALIZE_ERR                  = 82;


  interface DOMImplementationLS {

    // DOMImplementationLSMode
    const unsigned short      MODE_SYNCHRONOUS               = 1;
    const unsigned short      MODE_ASYNCHRONOUS              = 2;

    LSParser           createLSParser(in unsigned short mode, 
                                      in DOMString schemaType)
                                        raises(dom::DOMException);
    LSSerializer       createLSSerializer();
    LSInput            createLSInput();
    LSOutput           createLSOutput();
  };

  interface LSParser {
    readonly attribute DOMConfiguration domConfig;
             attribute LSParserFilter  filter;
    readonly attribute boolean         async;
    readonly attribute boolean         busy;
    Document           parse(in LSInput input)
                                        raises(dom::DOMException, 
                                               LSException);
    Document           parseURI(in DOMString uri)
                                        raises(dom::DOMException, 
                                               LSException);

    // ACTION_TYPES
    const unsigned short      ACTION_APPEND_AS_CHILDREN      = 1;
    const unsigned short      ACTION_REPLACE_CHILDREN        = 2;
    const unsigned short      ACTION_INSERT_BEFORE           = 3;
    const unsigned short      ACTION_INSERT_AFTER            = 4;
    const unsigned short      ACTION_REPLACE                 = 5;

    Node               parseWithContext(in LSInput input, 
                                        in Node contextArg, 
                                        in unsigned short action)
                                        raises(dom::DOMException, 
                                               LSException);
    void               abort();
  };

  interface LSInput {
    // Depending on the language binding in use,
    // this attribute may not be available.
             attribute LSReader        characterStream;
             attribute LSInputStream   byteStream;
             attribute DOMString       stringData;
             attribute DOMString       systemId;
             attribute DOMString       publicId;
             attribute DOMString       baseURI;
             attribute DOMString       encoding;
             attribute boolean         certifiedText;
  };

  interface LSResourceResolver {
    LSInput            resolveResource(in DOMString type, 
                                       in DOMString namespaceURI, 
                                       in DOMString publicId, 
                                       in DOMString systemId, 
                                       in DOMString baseURI);
  };

  interface LSParserFilter {

    // Constants returned by startElement and acceptNode
    const short               FILTER_ACCEPT                  = 1;
    const short               FILTER_REJECT                  = 2;
    const short               FILTER_SKIP                    = 3;
    const short               FILTER_INTERRUPT               = 4;

    unsigned short     startElement(in Element elementArg);
    unsigned short     acceptNode(in Node nodeArg);
    readonly attribute unsigned long   whatToShow;
  };

  interface LSSerializer {
    readonly attribute DOMConfiguration domConfig;
             attribute DOMString       newLine;
             attribute LSSerializerFilter filter;
    boolean            write(in Node nodeArg, 
                             in LSOutput destination)
                                        raises(LSException);
    boolean            writeToURI(in Node nodeArg, 
                                  in DOMString uri)
                                        raises(LSException);
    DOMString          writeToString(in Node nodeArg)
                                        raises(dom::DOMException, 
                                               LSException);
  };

  interface LSOutput {
    // Depending on the language binding in use,
    // this attribute may not be available.
             attribute LSWriter        characterStream;
             attribute LSOutputStream  byteStream;
             attribute DOMString       systemId;
             attribute DOMString       encoding;
  };

  interface LSProgressEvent : events::Event {
    readonly attribute LSInput         input;
    readonly attribute unsigned long   position;
    readonly attribute unsigned long   totalSize;
  };

  interface LSLoadEvent : events::Event {
    readonly attribute Document        newDocument;
    readonly attribute LSInput         input;
  };

  interface LSSerializerFilter : traversal::NodeFilter {
    readonly attribute unsigned long   whatToShow;
  };
};

#endif // _LS_IDL_

