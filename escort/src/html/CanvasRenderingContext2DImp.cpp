// Generated by esidl 0.2.1.
// This file is expected to be modified for the Web IDL interface
// implementation.  Permission to use, copy, modify and distribute
// this file in any software license is hereby granted.

#include "CanvasRenderingContext2DImp.h"

namespace org
{
namespace w3c
{
namespace dom
{
namespace bootstrap
{

html::HTMLCanvasElement CanvasRenderingContext2DImp::getCanvas()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

void CanvasRenderingContext2DImp::save()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::restore()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::scale(double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::rotate(double angle)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::translate(double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::transform(double a, double b, double c, double d, double e, double f)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::setTransform(double a, double b, double c, double d, double e, double f)
{
    // TODO: implement me!
}

double CanvasRenderingContext2DImp::getGlobalAlpha()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setGlobalAlpha(double globalAlpha)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getGlobalCompositeOperation()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setGlobalCompositeOperation(const std::u16string& globalCompositeOperation)
{
    // TODO: implement me!
}

Any CanvasRenderingContext2DImp::getStrokeStyle()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setStrokeStyle(Any strokeStyle)
{
    // TODO: implement me!
}

Any CanvasRenderingContext2DImp::getFillStyle()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setFillStyle(Any fillStyle)
{
    // TODO: implement me!
}

html::CanvasGradient CanvasRenderingContext2DImp::createLinearGradient(double x0, double y0, double x1, double y1)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::CanvasGradient CanvasRenderingContext2DImp::createRadialGradient(double x0, double y0, double r0, double x1, double y1, double r1)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::CanvasPattern CanvasRenderingContext2DImp::createPattern(html::HTMLImageElement image, const std::u16string& repetition)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::CanvasPattern CanvasRenderingContext2DImp::createPattern(html::HTMLCanvasElement image, const std::u16string& repetition)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::CanvasPattern CanvasRenderingContext2DImp::createPattern(html::HTMLVideoElement image, const std::u16string& repetition)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

double CanvasRenderingContext2DImp::getLineWidth()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setLineWidth(double lineWidth)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getLineCap()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setLineCap(const std::u16string& lineCap)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getLineJoin()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setLineJoin(const std::u16string& lineJoin)
{
    // TODO: implement me!
}

double CanvasRenderingContext2DImp::getMiterLimit()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setMiterLimit(double miterLimit)
{
    // TODO: implement me!
}

double CanvasRenderingContext2DImp::getShadowOffsetX()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setShadowOffsetX(double shadowOffsetX)
{
    // TODO: implement me!
}

double CanvasRenderingContext2DImp::getShadowOffsetY()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setShadowOffsetY(double shadowOffsetY)
{
    // TODO: implement me!
}

double CanvasRenderingContext2DImp::getShadowBlur()
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::setShadowBlur(double shadowBlur)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getShadowColor()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setShadowColor(const std::u16string& shadowColor)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::clearRect(double x, double y, double w, double h)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::fillRect(double x, double y, double w, double h)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::strokeRect(double x, double y, double w, double h)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::beginPath()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::closePath()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::moveTo(double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::lineTo(double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::quadraticCurveTo(double cpx, double cpy, double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::bezierCurveTo(double cp1x, double cp1y, double cp2x, double cp2y, double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::arcTo(double x1, double y1, double x2, double y2, double radius)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::rect(double x, double y, double w, double h)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::arc(double x, double y, double radius, double startAngle, double endAngle)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::arc(double x, double y, double radius, double startAngle, double endAngle, bool anticlockwise)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::fill()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::stroke()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawSystemFocusRing(Element element)
{
    // TODO: implement me!
}

bool CanvasRenderingContext2DImp::drawCustomFocusRing(Element element)
{
    // TODO: implement me!
    return 0;
}

void CanvasRenderingContext2DImp::scrollPathIntoView()
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::clip()
{
    // TODO: implement me!
}

bool CanvasRenderingContext2DImp::isPointInPath(double x, double y)
{
    // TODO: implement me!
    return 0;
}

std::u16string CanvasRenderingContext2DImp::getFont()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setFont(const std::u16string& font)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getTextAlign()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setTextAlign(const std::u16string& textAlign)
{
    // TODO: implement me!
}

std::u16string CanvasRenderingContext2DImp::getTextBaseline()
{
    // TODO: implement me!
    return u"";
}

void CanvasRenderingContext2DImp::setTextBaseline(const std::u16string& textBaseline)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::fillText(const std::u16string& text, double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::fillText(const std::u16string& text, double x, double y, double maxWidth)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::strokeText(const std::u16string& text, double x, double y)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::strokeText(const std::u16string& text, double x, double y, double maxWidth)
{
    // TODO: implement me!
}

html::TextMetrics CanvasRenderingContext2DImp::measureText(const std::u16string& text)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLImageElement image, double dx, double dy)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLImageElement image, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLImageElement image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLCanvasElement image, double dx, double dy)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLCanvasElement image, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLCanvasElement image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLVideoElement image, double dx, double dy)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLVideoElement image, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::drawImage(html::HTMLVideoElement image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh)
{
    // TODO: implement me!
}

html::ImageData CanvasRenderingContext2DImp::createImageData(double sw, double sh)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::ImageData CanvasRenderingContext2DImp::createImageData(html::ImageData imagedata)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::ImageData CanvasRenderingContext2DImp::getImageData(double sx, double sy, double sw, double sh)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

void CanvasRenderingContext2DImp::putImageData(html::ImageData imagedata, double dx, double dy)
{
    // TODO: implement me!
}

void CanvasRenderingContext2DImp::putImageData(html::ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight)
{
    // TODO: implement me!
}

}
}
}
}
