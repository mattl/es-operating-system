// Generated by esidl (r1752).
// This file is expected to be modified for the Web IDL interface
// implementation.  Permission to use, copy, modify and distribute
// this file in any software license is hereby granted.

#include "HTMLMediaElementImp.h"

namespace org
{
namespace w3c
{
namespace dom
{
namespace bootstrap
{

html::MediaError HTMLMediaElementImp::getError()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

std::u16string HTMLMediaElementImp::getSrc()
{
    // TODO: implement me!
    return u"";
}

void HTMLMediaElementImp::setSrc(std::u16string src)
{
    // TODO: implement me!
}

std::u16string HTMLMediaElementImp::getCurrentSrc()
{
    // TODO: implement me!
    return u"";
}

std::u16string HTMLMediaElementImp::getCrossOrigin()
{
    // TODO: implement me!
    return u"";
}

void HTMLMediaElementImp::setCrossOrigin(std::u16string crossOrigin)
{
    // TODO: implement me!
}

unsigned short HTMLMediaElementImp::getNetworkState()
{
    // TODO: implement me!
    return 0;
}

std::u16string HTMLMediaElementImp::getPreload()
{
    // TODO: implement me!
    return u"";
}

void HTMLMediaElementImp::setPreload(std::u16string preload)
{
    // TODO: implement me!
}

html::TimeRanges HTMLMediaElementImp::getBuffered()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

void HTMLMediaElementImp::load()
{
    // TODO: implement me!
}

std::u16string HTMLMediaElementImp::canPlayType(std::u16string type)
{
    // TODO: implement me!
    return u"";
}

unsigned short HTMLMediaElementImp::getReadyState()
{
    // TODO: implement me!
    return 0;
}

bool HTMLMediaElementImp::getSeeking()
{
    // TODO: implement me!
    return 0;
}

double HTMLMediaElementImp::getCurrentTime()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setCurrentTime(double currentTime)
{
    // TODO: implement me!
}

double HTMLMediaElementImp::getInitialTime()
{
    // TODO: implement me!
    return 0;
}

double HTMLMediaElementImp::getDuration()
{
    // TODO: implement me!
    return 0;
}

unsigned long long HTMLMediaElementImp::getStartOffsetTime()
{
    // TODO: implement me!
    return 0;
}

bool HTMLMediaElementImp::getPaused()
{
    // TODO: implement me!
    return 0;
}

double HTMLMediaElementImp::getDefaultPlaybackRate()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setDefaultPlaybackRate(double defaultPlaybackRate)
{
    // TODO: implement me!
}

double HTMLMediaElementImp::getPlaybackRate()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setPlaybackRate(double playbackRate)
{
    // TODO: implement me!
}

html::TimeRanges HTMLMediaElementImp::getPlayed()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::TimeRanges HTMLMediaElementImp::getSeekable()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

bool HTMLMediaElementImp::getEnded()
{
    // TODO: implement me!
    return 0;
}

bool HTMLMediaElementImp::getAutoplay()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setAutoplay(bool autoplay)
{
    // TODO: implement me!
}

bool HTMLMediaElementImp::getLoop()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setLoop(bool loop)
{
    // TODO: implement me!
}

void HTMLMediaElementImp::play()
{
    // TODO: implement me!
}

void HTMLMediaElementImp::pause()
{
    // TODO: implement me!
}

std::u16string HTMLMediaElementImp::getMediaGroup()
{
    // TODO: implement me!
    return u"";
}

void HTMLMediaElementImp::setMediaGroup(std::u16string mediaGroup)
{
    // TODO: implement me!
}

html::MediaController HTMLMediaElementImp::getController()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

void HTMLMediaElementImp::setController(html::MediaController controller)
{
    // TODO: implement me!
}

bool HTMLMediaElementImp::getControls()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setControls(bool controls)
{
    // TODO: implement me!
}

double HTMLMediaElementImp::getVolume()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setVolume(double volume)
{
    // TODO: implement me!
}

bool HTMLMediaElementImp::getMuted()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setMuted(bool muted)
{
    // TODO: implement me!
}

bool HTMLMediaElementImp::getDefaultMuted()
{
    // TODO: implement me!
    return 0;
}

void HTMLMediaElementImp::setDefaultMuted(bool defaultMuted)
{
    // TODO: implement me!
}

html::AudioTrackList HTMLMediaElementImp::getAudioTracks()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::VideoTrackList HTMLMediaElementImp::getVideoTracks()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::TextTrackList HTMLMediaElementImp::getTextTracks()
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::MutableTextTrack HTMLMediaElementImp::addTextTrack(std::u16string kind)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::MutableTextTrack HTMLMediaElementImp::addTextTrack(std::u16string kind, std::u16string label)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

html::MutableTextTrack HTMLMediaElementImp::addTextTrack(std::u16string kind, std::u16string label, std::u16string language)
{
    // TODO: implement me!
    return static_cast<Object*>(0);
}

}
}
}
}
