/*
 * Copyright 2011 Esrille Inc.
 * Copyright 2008, 2009 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <es/any.h>

// The apply functions are implemented in C++ so that these can support C++
// exceptions.

namespace
{

Any apply(int argc, Any* argv, void (*function)(), unsigned resultType)
{
    // Do not invoke C++ functions inside apply(). Otherwise, the stack will
    // be polluted while the stack frame for function is being built.
    Any* result;
    __asm__ __volatile__ (
        "movl   8(%%ebp), %0\n"
        :"=r"(result)
    );
    for (argv += argc - 1; 0 < argc; --argc, --argv)
    {
        unsigned type;
        __asm__ __volatile__ (
            "movl   8(%1), %0\n"
            :"=r"(type) :"r"(argv)
        );
        if (type & Any::FlagAny)
        {
            __asm__ __volatile__ (
                "pushl  %0\n"
                "pushl  4(%1)\n"
                "pushl  (%1)\n"
                ::"r"(type), "r"(argv)
            );
            continue;
        }
        switch (type)
        {
        case Any::TypeBool:
        case Any::TypeOctet:
            __asm__ __volatile__ (
                "movzbl (%0), %%edx\n"
                "pushl   %%edx\n"
                ::"r"(argv) : "%edx"
            );
            break;
        case Any::TypeShort:
        case Any::TypeUnsignedShort:
            __asm__ __volatile__ (
                "movzwl (%0), %%edx\n"
                "pushl   %%edx\n"
                ::"r"(argv) : "%edx"
            );
            break;
        case Any::TypeLong:
        case Any::TypeUnsignedLong:
        case Any::TypeFloat:
        case Any::TypeObject:
        case Any::TypeString:
            __asm__ __volatile__ (
                "pushl  (%0)\n"
                ::"r"(argv)
            );
            break;
        case Any::TypeLongLong:
        case Any::TypeUnsignedLongLong:
        case Any::TypeDouble:
            __asm__ __volatile__ (
                "pushl  4(%0)\n"
                "pushl  (%0)\n"
                ::"r"(argv)
            );
            break;
        // case Any::TypeString:
        default:
            __asm__ __volatile__ (
                "pushl  %0\n"
                ::"r"(argv)
            );
            break;
        }
    }
    if ((resultType & Any::FlagAny) /* || result->getType() == Any::TypeString */)
    {
        __asm__ __volatile__ (
            "pushl  %0\n"
            ::"r"(result)
        );
        function();
        __asm__ __volatile__ (
            "movl   %0, %%eax\n"
            "leave\n"
            "ret    $4\n"
            ::"r"(result) : "%eax"
        );
    }
    else
    {
        switch (resultType)
        {
        case Any::TypeFloat:
            function();
            __asm__ __volatile__ (
                "fstps  0(%0)\n"
                ::"r"(result)
            );
            break;
        case Any::TypeDouble:
            function();
            __asm__ __volatile__ (
                "fstpl  0(%0)\n"
                ::"r"(result)
            );
            break;
        default:
            function();
            __asm__ __volatile__ (
                "movl   %%eax, 0(%0)\n"
                "movl   %%edx, 4(%0)\n"
                ::"r"(result) : "%eax", "%edx"
            );
            break;
        }
    }
    __asm__ __volatile__ (
        "movl   %0, %%eax\n"
        "movl   %1, 8(%%eax)\n"
        "leave\n"
        "ret    $4\n"
        ::"r"(result), "r"(resultType) : "%eax"
    );
    // Note we cannot assume that the function epilogue generated by the 
    // compiler uses the ordinary leave and ret pair since the compiler
    // cannot tell extra arguments has been pushed inside this function.
    // For instance, gcc 4.6.1 chooses the add, pop, and ret sequence.
}

}  // namespace

Any apply(int argc, Any* argv, bool (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 1);
}

Any apply(int argc, Any* argv, uint8_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 2);
}

Any apply(int argc, Any* argv, int16_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 3);
}

Any apply(int argc, Any* argv, uint16_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 4);
}

Any apply(int argc, Any* argv, int32_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 5);
}

Any apply(int argc, Any* argv, uint32_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 6);
}

Any apply(int argc, Any* argv, int64_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 7);
}

Any apply(int argc, Any* argv, uint64_t (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 8);
}

Any apply(int argc, Any* argv, float (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 9);
}

Any apply(int argc, Any* argv, double (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 10);
}

Any apply(int argc, Any* argv, const char* (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 11);
}

#if 0
Any apply(int argc, Any* argv, std::string (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 11);
}
#endif

Any apply(int argc, Any* argv, Object* (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 12);
}

Any apply(int argc, Any* argv, Any (*function)())
{
    return apply(argc, argv, reinterpret_cast<void (*)()>(function), 0x80000000);
}

long long evaluate(const Any& variant)
{
    switch (variant.getType())
    {
    case Any::TypeBool:
        return static_cast<bool>(variant);
        break;
    case Any::TypeOctet:
        return static_cast<uint8_t>(variant);
        break;
    case Any::TypeShort:
        return static_cast<int16_t>(variant);
        break;
    case Any::TypeUnsignedShort:
        return static_cast<uint16_t>(variant);
        break;
    case Any::TypeLong:
        return static_cast<int32_t>(variant);
        break;
    case Any::TypeUnsignedLong:
        return static_cast<uint32_t>(variant);
        break;
    case Any::TypeLongLong:
        return static_cast<int64_t>(variant);
        break;
    case Any::TypeUnsignedLongLong:
        return static_cast<uint64_t>(variant);
        break;
    case Any::TypeFloat:
        __asm__ __volatile__ (
            "flds   (%0)\n"
            :: "r"(&variant)
        );
        break;
    case Any::TypeDouble:
        __asm__ __volatile__ (
            "fldl   (%0)\n"
            :: "r"(&variant)
        );
        break;
    case Any::TypeString:
        return reinterpret_cast<long long>(static_cast<const char*>(variant));
        break;
    case Any::TypeObject:
        return reinterpret_cast<long long>(static_cast<Object*>(variant));
        break;
    default:
        break;
    }
    return 0;
}
